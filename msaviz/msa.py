# -*- coding: utf-8 -*-
"""
This module implements two classes which carry out all of the calculations
required to predict the wavelength-pixel relationship for open shutters
based on a given MSA configuration and instrument setup.

The `~msaviz.MSA` class integrates the dispersion curve for the chosen
filter based on initial conditions generated by the NIRSpec instrument
model (calibrated with test data).

Meanwhile, the `~msaviz.MSAConfig` class includes methods to parse an
MSA config file, and calculate wavelengths and useful statistics based
on the open shutters for that configuration.

In addition, three utility functions (`~msaviz.check_wavelengths`, 
`~msaviz.parse_msa_config`, and `~msaviz.wavelength_table`) provide 
simple wrappers for some of the MSAConfig methods.

All of these are available from the top-level msaviz module, and represent
the API for the msaviz package.
"""

from __future__ import absolute_import, division, print_function

import json
from collections import namedtuple
import csv
import os

from astropy.io import fits
from astropy.table import Table, QTable, Row
from scipy.integrate import odeint
from astropy.modeling import models, fitting
import astropy.units as u
from scipy.interpolate import interp1d
import numpy as np

from .shuttercoord import ShutterCoord

#Use namedtuple to define the container for each quadrant of each reference
#file, in a format which is very easily serializable to JSON.
QuadrantModel = namedtuple('QuadrantBase', ['filter','grating','quadrant',
                                           'type1', 'param1', 'pix1', 
                                           'type2', 'param2', 'pix2'])

base_dir = os.path.dirname(os.path.realpath(__file__))

edges_file = os.path.join(base_dir, 'data', 'edges.json')
range_file = os.path.join(base_dir, 'data', 'ranges.json')
prism_file = os.path.join(base_dir, 'data', 
                          'jwst_nirspec_prism_mos_wavelengths.fits')
disp_files = os.path.join(base_dir, 'data', 'jwst_nirspec_{}_disp.fits')

with open(edges_file) as f:
    edge_data = json.load(f)

quadrant_data = {}
for fg, edge in edge_data.items():
    f,g = fg.split("/")
    filtgrat = {}
    for q, sca in edge.items():
        filtgrat[int(q)] = QuadrantModel._make(sca)
    quadrant_data[(f,g)] = filtgrat

with open(range_file) as f:
    range_data = json.load(f)

#The prism requires some special handling, and has its own dedicated file.

def parse_msa_config(filename, open_only=True):
    """
    Parse an MSA config file to determine the status of the shutters.
    
    This function reads an MSA config file exported from APT, which is 
    in Comma-Separated Values (CSV) format, and contains a representation
    of all the shutters in the MSA, each of which is assigned one of the
    following status flags:
        'x' -> inactive
        '0' -> open
        '1' -> closed
        's' -> stuck open
    
    Parameters
    ----------
    filename : str
        The path to the MSA config file
    open_only : bool, optional
        Whether to return a dictionary of only the open & stuck-open 
        shutters. If False, then the return result will contain the 
        status of every shutter.
        
    Returns
    -------
    result : dict
        A dictionary with keys as 3-coordinate tuples (quadrant Q, 
        column I, row J) for each shutter, and a boolean value which is
        True if the indicated shutter is stuck open.
    
    Notes
    -----
    The CSV file has 730 rows and 342 columns. However, native MSA 
    coordinates use 1-based indexing, with 365 columns (increasing from
    right to left) and 171 rows (increasing from the top down) for each
    of the four quadrants. For more information, see the `JWST NIRspec
    MOS documentation <https://jwst-docs.stsci.edu/display/JTI/NIRSpec+Multi+Object+Spectroscopy>`_
    
    To convert between the two coordinate systems, rows and columns in the
    CSV file are swapped, and the quadrants are then assigned as follows:
        - Q1 = col 365-729, row 000-170
        - Q2 = col 365-729, row 171-341
        - Q3 = col 000-364, row 000-170
        - Q4 = col 000-364, row 171-341
    
    Example
    -------
    
    >>> open_shutters = parse_msa_config('test/single_shutter.csv')
    >>> [qcr for qcr, stuck in open_shutters.items() if not stuck]
    [(0, 34, 29)]

    """
    
    shutters = []
    
    with open(filename) as csvfile:
        reader = csv.reader(csvfile)
        next(reader) #the first row is a comment
        for x, column in enumerate(reader):
            for y, shutter in enumerate(column):
                cc = ShutterCoord.from_xy(x, y)
                shutters.append((cc.qij, shutter))
                
    if open_only: #only keep the open  & stuck-open shutters, and convert
                  #status to a boolean (True for stuck-open)
        return {qij: (status == 's') for (qij, status) in shutters \
                    if status in '0s'}
    
    return dict(shutters)


class MSA(object):
    """
    The workhorse object for calculating pixel-to-wavelength mappings for
    a given filter+disperser combination.
    
    Generally, this is done by integrating over the dispersion curve for
    the chosen disperser, using initial conditions generated by the
    instrument model.
    
    Parameters
    ----------
    filtname : str
        The name of the filter, chosen from the list of NIRSpec filters.
    dispname : str
        The name of the disperser, chosen from the list of NIRSpec
        dispersers; must be paired with the chosen filter.
    
    Attributes
    ----------
    filter : str
        The name of the filter.
    disperser : str
        The name of the disperser.
    sci_range : list (float, float)
        The minimum and maximum wavelength of the filter transmission.
    dispersion : object
        A callable object which can be used to retrieve the dispersion
        value at the given wavelength(s).
    
    Notes
    -----
    For grating observations, the instrument model was used to determine
    the wavelength of the detector gap for a subset of shutters; this was
    then fit with a 2nd-degree 2D polynomial so that an initial condition
    could be generated for every shutter on the fly.
    
    For prism observations, a lookup-table of initial conditions for each
    shutter was generated with the instrument model. In addition, once the
    dispersion curve has been integrated, a 3rd-degree 1D polynomial
    correction (determined by comparison with the instrument model output)
    is applied to the solution.
    
    Examples
    --------
    >>> msa = MSA('f170lp', 'g235m')
    >>> msa([1, 150, 39])
    """
    
    def __init__(self, filtname, dispname):
        self.filter = filtname.lower()
        self.disperser = dispname.lower()
        self.sci_range = range_data["{}/{}".format(self.filter, 
                                                   self.disperser)]
        
        dtable = fits.getdata(disp_files.format(self.disperser),1)
        dwav = dtable['WAVELENGTH']
        dlds = dtable['DLDS']
        
        if self.disperser == "prism":
            self._quadrants = []
            for q in range(1,5):
                tab = Table.read(prism_file, q)
                tab.add_index('I')
                tab.add_index('J')
                self._quadrants.append(tab)
            self.dispersion = interp1d(dwav, dlds, fill_value='extrapolate')
        else:
            self._quadrants = quadrant_data[(self.filter, self.disperser)]
            fitter = fitting.LinearLSQFitter()
            self.dispersion = fitter(models.Polynomial1D(6), dwav, dlds)
    
    def __call__(self, coords):
        """
        Determine the wavelengths for the given set of shutter 
        coordinates.
        
        Parameters
        ----------
        coords : array-like
            A 3xN array of shutter coordinates, indicating the shutters
            for which wavelengths should be calculated.
        
        Returns
        -------
        wavelengths : array
            A 2xNx2048 array of wavelengths on each detector for each
            shutter, over the entire 2048 pixels of that detector.
        """
        coords = np.array(coords)
        if coords.ndim == 1: #enforce 3x1 for a single set of coordinates
            coords = coords[:, None] 
        
        ns = coords.shape[1]
        #we'll leave 0s wherever the spectrum doesn't fall on the detector
        wavelengths = np.zeros((2, ns, 2048), dtype=float)
        
        if self.disperser == "prism":
            #Unlike for the gratings, the prism is not integrated over 
            #the same set of pixels for each shutter. Therefore, we need 
            #to integrate each shutter individually.
            
            for idx,(q,c,r) in enumerate(coords.T):
                for n in (0,1):
                    wavelengths[n,idx] = self._prism_integrate(q,c,r,n)
        
        else:
            #For gratings, we only have two possible paths of integration: 
            #left-to-right, and right-to-left. Using the magic of ODEINT, 
            #we can integrate all of the shutters in each set of these
            #simultaneously, then combine the results.
            
            for q, quad in self._quadrants.items():
                if q not in coords[0]: #no shutters in this quadrant
                    continue
                #which shutters are in this quadrant?
                idx, = (coords[0] == q).nonzero()
                
                if quad.pix1 is not None: #include NRS1
                    wavelengths[0, idx] = self._grating_integrate(
                                           quad.pix1, quad.param1,
                                           coords[1,idx], coords[2,idx]).T
                
                if quad.pix2 is not None: #include NRS2
                    wavelengths[1, idx] = self._grating_integrate(
                                           quad.pix2, quad.param2,
                                           coords[1,idx], coords[2,idx]).T
        return wavelengths
    
    def _integrate_func(self, y, x):
        """
        Determine the dispersion at the given wavelength.
        
        The dispersion curves are only dependent on wavelength, not on
        pixel. This method is the integration function passed to ODEINT.
        
        Parameters
        ----------
        y : float or array-like
            The current wavelength.
        x : float or array-like
            The current pixel (not used, but passed by ODEINT).
        
        Returns
        -------
        dispersion : float or array-like
            The dispersion at the given wavelength (and pixel), in the 
            same format as y.
        """
        return self.dispersion(y)
        
    def _prism_integrate(self, quadrant, i, j, nrs):
        """
        Solve for the wavelengths of the indicated shutter on one of the
        detectors.
        
        To achieve this, we integrate over the prism dispersion curve, 
        then apply a 3rd-order 1D polynomial correction.
        
        Parameters
        ----------
        quadrant : int
            The (0-based) quadrant of the shutter.
        i : int
            The (0-based) column of the shutter in its quadrant.
        j : int
            The (0-based) row of the shutter in its quadrant.
        nrs : int
            Which detector to solve for: NRS1 (0) or NRS2 (1).
        
        Returns
        -------
        wavelengths : array
            A 2048-element array of the wavelength at each pixel.
            Any pixel which is not illuminated by the spectrum is set 
            to 0.
        """
        
        #Grab the initial conditions from the LUT
        data = self._quadrants[quadrant]
        try:
            d1 = data.loc['I', i+1]
            if isinstance(d1, Row):
                row = d1
            else:
                row = d1.loc['J', j+1]
        except KeyError as key:
            return None
        pix, wav, par = [row[_+"49{}".format(nrs+1)] for _ in ['PIX','WAV','PAR']]
        
        if ~np.isfinite(wav):
            return None
        
        #Determine which pixels to integrate over
        all_pix = np.arange(2048, dtype=float)
        in_bounds = np.logical_and(all_pix >= pix[0], all_pix <= pix[1])
        integrate_pixels = [pix[0]] + all_pix[in_bounds].tolist()
        
        #Actually integrate, and calculate the correction
        base, dinfo = odeint(self._integrate_func, wav, integrate_pixels, 
                             full_output=True)
        correction = models.Polynomial1D(degree=3, c0=par[0], c1=par[1], 
                                         c2=par[2], c3=par[3])(all_pix[in_bounds])
        
        
        #Construct and return the wavelengths array
        try:
            wavelengths = np.zeros_like(all_pix)
            wavelengths[in_bounds] = base.squeeze()[1:] + correction
        except IndexError:
            import pdb; pdb.set_trace()
        
        return wavelengths
        
    def _grating_integrate(self, pix0, params, i0, j0):
        """
        Solve for the wavelengths of the indicated shutters, using the
        given ICs.
        
        To achieve this, we integrate over the grating dispersion curve.
        
        Parameters
        ----------
        pix0 : int
            The starting pixel on the detector (either 0 or 2047).
        params : list
            The 2D polynomial model parameters for this filter, grating,
            and MSA quadrant.
        i0 : array
            The (0-based) columns of the shutters in their quadrant.
        j0 : int
            The (0-based) rows of the shutters in their quadrant.
        
        Returns
        -------
        wavelengths : array
            A 2048xN array of the wavelength at each pixel for each
            shutter. Any pixel which is not illuminated by the spectrum
            is set to 0.
        """
        dx = [-1,1][pix0 == 0] #integration direction
        pixels = np.arange(2048, dtype=float) #pixels at which to integrate
        
        #Wavelength IC
        model = models.Polynomial2D(2)
        model.parameters = params
        wav0 = model(j0, i0)
        
        #integrate
        wavelengths= odeint(self._integrate_func, wav0, pixels[::dx])
        
        return wavelengths[::dx] #go back to pixels 0->2047

class MSAConfig(object):
    """
    A class to parse MSA config files and apply the calculations of the
    MSA object to the open shutters.
    
    As the specific calculations provided by the MSA class are rarely
    required by themselves, this class is the interface for general
    consumption.
    
    Parameters
    ----------
    filtname : str, optional
        The name of the filter, chosen from the list of NIRSpec filters.
        While this parameter is optional at instantiation, a filter name
        must be provided before any calculations can be performed.
    dispname : str, optional
        The name of the disperser, chosen from the list of NIRSpec
        dispersers; must be paired with the chosen filter. While this 
        parameter is optional at instantiation, a disperser name must 
        be provided before any calculations can be performed.
    config_file : str, optional
        The path to the MSA config file. While this parameter is optional
        at instantiation, a config file must be provided before any
        calculations can be performed.
    
    Attributes
    ----------
    wavelength_table
    conf : str
        The path to the MSA config file.
    fname : str
        The name of the chosen filter.
    dname : str
        The name of the chosen disperser.
    nopen : int
        The number of open shutters (not including stuck-open).
    sci_range : list
        A 2-element list comprised of the minimum and maximum wavelength
        transmitted by the chosen filter.
    """
    
    def __init__(self, filtname="", dispname="", config_file=""):
        self._msa = None
        self._oidx = None
        self._nrs = None
        self._stu = None
        self._shutter_limits = None
        self._open_shutters = {}
        self.conf = ""
        self.fname = ""
        self.dname = ""
        self.nopen = 0
        self.sci_range = []
        
        self.update_instrument(filtname, dispname)
        self.update_config(config_file)
        
    def update_config(self, config_file):
        """
        Parse an MSA config file.
        
        The shutter coordinates and stuck-open flags are stored as
        numpy arrays for ease of calculations.
        
        Parameters
        ----------
        config_file : str
            The path to the MSA config file which will be parsed.
            
        Notes
        -----
        This method can be used to change to a different config file
        while keeping all other parameters the same.
        """
        if not config_file:
            return
        self.conf = config_file
        self._open_shutters = parse_msa_config(self.conf)
        
        qrc,s = zip(*sorted(self._open_shutters.items()))
        self._quads, self._cols, self._rows = np.vstack(list(zip(*qrc)))
        self._stuck = np.array(s)
        self._opens = ~self._stuck
        self._oidx, = self._opens.nonzero()
        self.nopen = self._oidx.size
        self._calculate()
    
    def update_instrument(self, filtname, dispname):
        """
        Update the filter and disperser settings.
        
        This method instantiates the MSA calculation object based
        on the filter + disperser choice.
        
        Parameters
        ----------
        filtname : str
            The name of the filter, chosen from the list of NIRSpec 
            filters.
        dispname : str
            The name of the disperser, chosen from the list of NIRSpec
            dispersers; must be paired with the chosen filter.
            
        Notes
        -----
        This method can be used to change to a different filter + 
        disperser, without having to re-parse the MSA config file.
        """
        if not filtname or not dispname:
            return
        self.fname = filtname
        self.dname = dispname
        
        self._msa = MSA(self.fname, self.dname)
        self.sci_range = self._msa.sci_range
        self._calculate()
    
    def wavelength(self, quadrants, rows, columns):
        """
        Calculate the wavelength arrays for the given shutter coords.
        
        This is just a wrapper around the callable MSA object, which
        is a private attribute in this class.
        
        Parameters
        ----------
        quadrants, rows, columns : array-like
            Arrays of length N, comprised of shutter coordinates for
            which to calculated wavelengths
        
        Returns
        -------
        wavelengths : array
            A 2xNx2048 array of wavelengths, as per MSA.__call__().
        """
        
        if not self.conf or not self.fname:
            return None
        return self._msa(np.vstack((quadrants, rows, columns)))
        
    def _calculate(self):
        """
        Calculate the wavelengths for all open shutters.
        
        This method is called whenever the filter, disperser, or config
        file are updated.
        
        Parameters
        ----------
        None
        """
        
        self._nrs = np.zeros((2,2,171,2048), dtype=float)
        self._stu = np.zeros((2,2,171,2048), dtype=float)
        self._shutter_limits = None
        
        if not self.conf or not self.fname:
            return
        
        o = self._opens
        s = self._stuck
        coords = np.vstack((self._quads, self._cols, self._rows))

        lo, hi = self.sci_range
        all_waves = self._msa(coords)
        top = 1 - self._quads % 2
        lims = np.full((self.nopen, 4), np.nan, dtype=float)
        
        for n, waves in enumerate(all_waves):
            wopen = waves[o]
            wstuck = waves[s]
            
            self._stu[n, top[s], 170-coords[2,s]] = wstuck
            self._nrs[n, top[o], 170-coords[2,o]] = wopen
            
            fin, = np.any(np.isfinite(wopen), axis=1).nonzero() #ensure there's at least one good value
            ok = fin[np.logical_and(np.nanmin(wopen[fin],axis=1) <= hi,
                                    np.nanmax(wopen[fin],axis=1) >= lo)]
            lims[ok,   n*2] = np.maximum(wopen[ok].min(axis=1), lo)
            lims[ok, 1+n*2] = np.minimum(wopen[ok].max(axis=1), hi)
        self._shutter_limits = lims
    
    @property
    def _table_meta(self):
        """
        A shorthand read-only property for filling in table metadata.
        
        Parameters
        ----------
        None
        
        Returns
        -------
        meta : dict
            A dictionary of metadata, with useful information stored in
            the "comments" field so that the ascii writer will include
            it when writing the table to a file.
        """
        return {"comments":["MSA Config File: {}".format(self.conf),
                            "Open shutters: {}".format(self.nopen),
                            "Filter: {}".format(self.fname),  
                            "Disperser: {}".format(self.dname)]}
    
    @property
    def wavelength_table(self):
        """
        Generate a QTable of wavelength bounds on each detector for each
        open shutter.
        
        Parameters
        ----------
        None.
            
        Returns
        -------
        shutters : `~astropy.table.QTable`
            A table of coordinates and wavelength limits on each detector
            for each shutter.
        """
        
        limits = self._shutter_limits * u.micron
        lo1, hi1, lo2, hi2 = limits.T
        q, c, r = (self._quads[self._oidx] + 1, 
                   self._cols[self._oidx] + 1, 
                   self._rows[self._oidx] + 1)
        
        
        shutters = QTable([q, c, r, lo1, hi1, lo2, hi2], 
                          names=["Quadrant", "Column", "Row", "NRS1-min",
                                 "NRS1-max", "NRS2-min", "NRS2-max"],
                          meta=self._table_meta, masked=True,
                          dtype=('i4','i4','i4','f8','f8','f8','f8'))
        
        shutters['NRS1-min'].info.format = '6.4f'
        shutters['NRS1-max'].info.format = '6.4f'
        shutters['NRS2-min'].info.format = '6.4f'
        shutters['NRS2-max'].info.format = '6.4f'
        
        shutters['NRS1-min'].mask = ~np.isfinite(lo1)
        shutters['NRS1-max'].mask = ~np.isfinite(hi1)
        shutters['NRS2-min'].mask = ~np.isfinite(lo2)
        shutters['NRS2-max'].mask = ~np.isfinite(hi2)
        
        return shutters
    
    def write_wavelength_table(self, outfile):
        """
        A convenience method to write the output of the wavelength_table
        property to a file.
        
        Parameters
        ----------
        outfile : str
            The filename (and path) of the file to which the table
            will be written.
        """
        self.wavelength_table.write(outfile, 
                                    format='ascii.fixed_width_two_line')
    
    def verify_wavelength(self, target, verbose=True):
        """
        Determine generally where the input wavelengths fall with respect
        to each open shutter.
        
        This method answers the question: for each open shutter, does the
        target wavelength fall on one of the two detectors?
        
        Parameters
        ----------
        target : float or array-like
            A scalar wavelength or array of wavelengths in microns (units
            need not be included) to test agains the wavelength limits for
            each detector.
        verbose : bool, optional
            Whether or not to output some very basic statistics about the 
            set of target wavelengths.
            
        Returns
        -------
        flags : `~astropy.table.QTable`
            A table where each row is associated with an open shutter in
            the MSA (with coordinates included), and contains a flag for
            each target wavelength that falls within the filter's science
            range:
            -2 -> the target wavelength falls to the right of NRS2
            -1 -> the target wavelength falls to the left of NRS1
             0 -> the target wavelength falls in the detector gap
             1 -> the target wavelength appears on NRS1
             2 -> the target wavelength appears on NRS2
             3 -> the target wavelength appears near the edge of NRS1, 
                  and may require special attention
             4 -> the target wavelength appears near the edge of NRS2, 
                  and may require special attention
        """
        targets = np.atleast_1d(target)
        if not isinstance(targets, u.Quantity):
            targets = targets * u.micron
        
        ok = np.logical_and(targets >= self.sci_range[0] * u.micron,
                            targets <= self.sci_range[1] * u.micron)
        
        if np.count_nonzero(ok) == 0:
            print("No target wavelength falls inside the filter " \
                  "transmission range.")
            return
        
        if np.count_nonzero(ok) != targets.size:
            if verbose:
                print("Trimming target wavelengths outside the filter " \
                      "transmission range...")
            targets = targets[ok]
        
        nt = targets.size
        
        #Grab input table
        table = self.wavelength_table
        
        #Create output table
        meta = self._table_meta
        meta["comments"].extend([
                "Description of flags:",
                "  -2 : the target wavelength falls to the right of NRS2",
                "  -1 : the target wavelength falls to the left of NRS1",
                "   0 : the target wavelength falls in the detector gap",
                "   1 : the target wavelength appears on NRS1",
                "   2 : the target wavelength appears on NRS2",
                "   3 : the target wavelength appears near the edge of " \
                    "NRS1, and may require special attention",
                "   4 : the target wavelength appears near the edge of " \
                    "NRS2, and may require special attention"
                    ])
        flags = QTable(meta=meta, masked=True)
        
        flags['Quadrant'] = table['Quadrant']
        flags['Column'] = table['Column']
        flags['Row'] = table['Row']
        
        flag = np.zeros((self.nopen, nt), dtype=int)
        
        dwav = self._msa.dispersion(targets.value) * u.micron
        fvalues = np.array([-1, 1, 0, 2, -2])
        
        for i, row in enumerate(table):
            #can't create an array from individual Quantity objects...
            bounds = np.array([row['NRS{}-{}'.format(d,x)].value for d in '12' \
                                   for x in ['min','max']]) * u.micron
            
            #locate the targets w/r/t the detector bounds
            f = np.searchsorted(bounds, targets, side='right')
            flag[i] = fvalues[f]
            
            on1, = np.nonzero(f == 1)
            on2, = np.nonzero(f == 3)
            
            if np.count_nonzero(on1) > 0:
                close = np.logical_or((bounds[1] - targets[on1]) / dwav[on1] <= 20,
                                      (targets[on1] - bounds[0]) / dwav[on1] <= 20)
                flag[i, on1][close] = 3
            if np.count_nonzero(on2) > 0:
                if np.count_nonzero(~np.isfinite(bounds[2:])) > 0 or np.count_nonzero(~np.isfinite(targets[on2])) > 0:
                    import pdb; pdb.set_trace()
                close = np.logical_or((bounds[3] - targets[on2]) / dwav[on2] <= 20,
                                      (targets[on2] - bounds[2]) / dwav[on2] <= 20)
                flag[i, on2][close] = 3
        
        flag = flag.T
        
        for i,t in enumerate(targets):
            flags["{0:0.03f}".format(t)] = flag[i]
        
        if verbose:
            txt = ['in the detector gap', 'on NRS1', 'on NRS2', 
                   'near the edge of NRS1', 'near the edge of NRS2',
                   'to the right of NRS2', 'to the left of NRS1']
            
            for f,t in zip(flag, targets):
                print("Target wavelength {}:".format(t))
                for x in range(-2,5):
                    nf = np.count_nonzero(f == x)
                    if  nf > 0:
                        print(" -> falls {} for {:.1%} of shutters".format(txt[x], 
                                          nf / self.nopen))
        
        return flags
        

def wavelength_table(config_file, filtname, dispname, outfile=None):
    """
    A wrapper for `~msaviz.MSAConfig.wavelength_table` and 
    `~msaviz.MSAConfig.write_wavelength_table`, in case the user doesn't
    need to make use of the full functionality of the MSAConfig class.
    
    Parameters
    ----------
    config_file : str
        The path to the MSA config file.
    filtname : str
        The name of the filter, chosen from the list of NIRSpec filters.
    dispname : str
        The name of the disperser, chosen from the list of NIRSpec
        dispersers; must be paired with the chosen filter.
    outfile : str, optional
        If present, the wavelength table will be written to this file.
    
    Returns
    -------
    table : `~astropy.table.QTable`
            A table of coordinates and wavelength limits on each detector
            for each shutter.
    """
    
    msaconf = MSAConfig(filtname, dispname, config_file)
    
    if outfile:
        msaconf.write_wavelength_table(outfile)
    return msaconf.wavelength_table

def check_wavelengths(wavelengths, config_file, filtname, dispname, 
                      outfile=None, verbose=True):
    """
    A wrapper for `~msaviz.MSAConfig.verify_wavelength`, in case the user
    doesn't need to make use of the full functionality of the MSAConfig 
    class.
    
    Parameters
    ----------
    wavelengths : float or array-like
        A scalar wavelength or array of wavelengths in microns (units need 
        not be included) to test agains the wavelength limits for each 
        detector.
    config_file : str
        The path to the MSA config file.
    filtname : str
        The name of the filter, chosen from the list of NIRSpec filters.
    dispname : str
        The name of the disperser, chosen from the list of NIRSpec
        dispersers; must be paired with the chosen filter.
    outfile : str, optional
        If present, the flags table will be written to this file.
    verbose : bool, optional
        Whether or not to output some very basic statistics about the set
        of target wavelengths.
            
    Returns
    -------
    flag_table : `~astropy.table.QTable`
        A table where each row is associated with an open shutter in
        the MSA (with coordinates included), and contains a flag for
        each target wavelength that falls within the filter's science
        range:
        -2 -> the target wavelength falls to the right of NRS2
        -1 -> the target wavelength falls to the left of NRS1
         0 -> the target wavelength falls in the detector gap
         1 -> the target wavelength appears on NRS1
         2 -> the target wavelength appears on NRS2
         3 -> the target wavelength appears near the edge of NRS1, and may
              require special attention
         4 -> the target wavelength appears near the edge of NRS2, and may 
              require special attention
    
    Returns
    -------
    table : `~astropy.table.QTable`
            A table of coordinates and wavelength limits on each detector
            for each shutter.
    """
    msaconf = MSAConfig(filtname, dispname, config_file)
    flag_table = msaconf.verify_wavelength(wavelengths, verbose=verbose)
    
    if outfile:
        flag_table.write(outfile, format='ascii.fixed_width_two_line')
    
    return flag_table